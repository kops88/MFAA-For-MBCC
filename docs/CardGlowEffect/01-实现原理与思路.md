# 卡牌流光特效实现原理与思路

> 本文档详细介绍基于 **亮度检测 + GPU Shader** 实现卡牌流光效果的完整方案。

## 一、效果目标

实现类似《游戏王 Master Duel》的卡片流光效果：
- 只有卡牌上的**高亮区域**（如金色边框、发光宝石）才会产生流光
- 流光会沿着特定角度**动态移动**
- 支持多层流光叠加，产生丰富的视觉效果
- 可配置不同的颜色预设（金色、蓝色、紫色等）

## 二、核心思路

### 2.1 为什么选择亮度检测方案？

| 方案 | 优点 | 缺点 |
|------|------|------|
| 遮罩图方案 | 精确控制发光区域 | 需要为每张卡牌制作遮罩图 |
| **亮度检测方案** | 自动识别发光区域，无需额外资源 | 需要调参，可能误识别 |

**选择亮度检测的原因**：卡牌数量多，制作遮罩图工作量大；而卡牌的发光区域通常具有**高亮度+高饱和度**的特征，可以通过算法自动识别。

### 2.2 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                      CardGlowRenderer                        │
│  (Avalonia 自定义控件 - 继承自 Control)                       │
├─────────────────────────────────────────────────────────────┤
│  依赖属性:                                                    │
│  - Source: 卡牌图像                                          │
│  - Config: 流光配置                                          │
│  - IsGlowEnabled: 是否启用                                   │
├─────────────────────────────────────────────────────────────┤
│                           ↓                                  │
│              CompositionCustomVisual                         │
│        (Avalonia 合成层 - 支持 GPU 加速)                      │
├─────────────────────────────────────────────────────────────┤
│                           ↓                                  │
│                    CardGlowDraw                              │
│        (自定义渲染处理器 - 执行 Shader)                       │
├─────────────────────────────────────────────────────────────┤
│                           ↓                                  │
│               SkiaSharp + SKSL Shader                        │
│        (GPU 着色器 - 实现流光效果)                            │
└─────────────────────────────────────────────────────────────┘
```

## 三、技术实现详解

### 3.1 亮度检测算法

流光效果的核心是**识别哪些像素应该发光**。我们使用以下算法：

```
发光遮罩 = f(亮度, 饱和度, 色相)
```

#### 3.1.1 感知亮度计算

使用 ITU-R BT.601 标准计算人眼感知亮度：

```glsl
float getLuminance(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}
```

> **原理**：人眼对绿色最敏感，对蓝色最不敏感，所以绿色权重最高。

#### 3.1.2 RGB 转 HSV

为了分析颜色的饱和度和色相，需要将 RGB 转换为 HSV：

```glsl
vec3 rgb2hsv(vec3 c) {
    // ... 转换算法
    return vec3(hue, saturation, value);
}
```

- **H (Hue)**：色相，0-1 对应 0°-360°
- **S (Saturation)**：饱和度，越高颜色越鲜艳
- **V (Value)**：明度

#### 3.1.3 发光遮罩计算

```glsl
float calculateGlowMask(vec3 color) {
    // 1. 获取颜色属性
    vec3 hsv = rgb2hsv(color);
    float luminance = getLuminance(color);
    
    // 2. 基础判断：亮度和饱和度的软阈值
    float brightnessScore = smoothstep(threshold - 0.1, threshold + 0.1, luminance);
    float saturationScore = smoothstep(satThreshold - 0.1, satThreshold + 0.1, hsv.y);
    
    // 3. 加权组合
    float baseScore = brightnessScore * 0.7 + saturationScore * 0.3;
    
    // 4. 特殊色相加权（金色、蓝色等）
    float hueBonus = calculateHueBonus(hsv.x, hsv.y);
    
    return clamp(baseScore + hueBonus, 0.0, 1.0);
}
```

> **smoothstep** 函数产生平滑过渡，避免硬边界。

### 3.2 流光效果实现

#### 3.2.1 流光带计算

流光是一条沿特定角度移动的**光带**：

```glsl
float calculateFlowIntensity(vec2 uv, float speed, float width, float angle) {
    // 1. 计算像素在流光方向上的位置
    float flowPos = uv.x * cos(angle) + uv.y * sin(angle);
    
    // 2. 流光中心随时间移动
    float flowCenter = fract(iTime * speed);  // 0-1 循环
    
    // 3. 计算到流光中心的距离
    float dist = abs(flowPos - flowCenter);
    
    // 4. 高斯衰减 - 产生柔和边缘
    return exp(-dist * dist / (width * width * 0.5));
}
```

**图示**：
```
时间 t=0:     时间 t=0.5:     时间 t=1:
  ╱             ╲               ╱
 ╱               ╲             ╱
╱    流光带       ╲           ╱
                   ╲         ╱
                    ╲       ╱
```

#### 3.2.2 多层流光叠加

为了丰富效果，我们使用**两层流光**：

| 层级 | 方向 | 速度 | 宽度 | 作用 |
|------|------|------|------|------|
| 主流光 | 45° | 正常 | 较宽 | 主要视觉效果 |
| 次流光 | 135° | 1.5倍 | 较窄 | 增加层次感 |

```glsl
// 主流光
float mainFlow = calculateFlowIntensity(uv, speed, width, angle);

// 次流光 - 垂直于主流光
float secFlow = calculateFlowIntensity(uv, speed * 1.5, width * 0.5, angle + 1.57);
```

### 3.3 闪烁效果

在发光区域添加随机闪烁点：

```glsl
float calculateSparkle(vec2 uv, float mask) {
    // 1. 使用噪声生成随机位置
    float sparkleNoise = noise(uv * 20.0 + iTime * 0.5);
    
    // 2. 时间变化的闪烁强度
    float sparkleTime = sin(iTime * frequency + sparkleNoise * 6.28) * 0.5 + 0.5;
    
    // 3. 根据密度决定是否显示
    float sparkleMask = step(1.0 - density, random(floor(uv * 30.0)));
    
    return sparkleTime * sparkleMask * mask * intensity;
}
```

### 3.4 颜色混合模式

提供三种混合模式：

| 模式 | 公式 | 效果 |
|------|------|------|
| Add | `base + glow` | 最亮，可能过曝 |
| Screen | `1 - (1-base)(1-glow)` | 柔和提亮 |
| Overlay | 根据底色选择 | 保留细节 |

```glsl
vec3 blendColors(vec3 base, vec3 glow, float mode) {
    if (mode < 0.5) {
        return base + glow;  // Add
    } else if (mode < 1.5) {
        return 1.0 - (1.0 - base) * (1.0 - glow);  // Screen
    } else {
        // Overlay - 复杂逻辑
    }
}
```

## 四、渲染流程

### 4.1 初始化阶段

```
1. CardGlowRenderer 控件被添加到视觉树
        ↓
2. OnAttachedToVisualTree 被调用
        ↓
3. 获取 Compositor 并创建 CompositionCustomVisual
        ↓
4. 编译 SKSL Shader
        ↓
5. 将 Avalonia Bitmap 转换为 SKBitmap
        ↓
6. 创建 SKShader 用于 GPU 采样
```

### 4.2 每帧渲染

```
1. OnAnimationFrameUpdate 被调用
        ↓
2. 标记区域需要重绘 (Invalidate)
        ↓
3. OnRender 被调用
        ↓
4. 检查 GPU 是否可用
        ↓
   ┌─────────────────┬─────────────────┐
   │   GPU 可用      │   GPU 不可用    │
   ├─────────────────┼─────────────────┤
   │ 设置 Uniform    │ 直接绘制原图    │
   │ 执行 Shader     │ (软件回退)      │
   │ 绘制结果        │                 │
   └─────────────────┴─────────────────┘
```

### 4.3 Shader 执行流程

```glsl
vec4 main(vec2 fragCoord) {
    // 1. 归一化坐标
    vec2 uv = fragCoord / iResolution.xy;
    
    // 2. 采样原始图像
    vec4 originalColor = iImage.eval(fragCoord);
    
    // 3. 计算发光遮罩
    float glowMask = calculateGlowMask(originalColor.rgb);
    
    // 4. 如果遮罩太低，直接返回（性能优化）
    if (glowMask < 0.01) return originalColor;
    
    // 5. 计算各层流光
    vec3 mainFlowColor = ...;
    vec3 secFlowColor = ...;
    vec3 sparkleColor = ...;
    
    // 6. 合成并混合
    vec3 totalGlow = (mainFlowColor + secFlowColor + sparkleColor) * glowMask;
    vec3 finalColor = blendColors(originalColor.rgb, totalGlow, blendMode);
    
    return vec4(finalColor, originalColor.a);
}
```

## 五、性能优化

### 5.1 已实现的优化

1. **早期退出**：遮罩值低于阈值时直接返回原色
2. **预分配数组**：避免每帧创建新数组产生 GC
3. **软件回退**：GPU 不可用时直接绘制原图

### 5.2 可选优化

1. **降采样**：对大图进行降采样后处理
2. **LOD**：远距离卡牌使用简化效果
3. **批处理**：多张卡牌共享 Shader 实例

## 六、文件结构

```
MFAAvalonia/Views/UserControls/Card/
├── CardGlowRenderer.cs      # 主控件类
├── CardGlowConfig.cs        # 配置类（参数+预设）
└── CardGlowShader.sksl      # Shader 源码（参考）
```

## 七、总结

本方案通过以下技术实现了高质量的卡牌流光效果：

| 技术 | 作用 |
|------|------|
| 亮度检测 | 自动识别发光区域 |
| SKSL Shader | GPU 加速渲染 |
| CompositionCustomVisual | Avalonia 合成层集成 |
| 多层流光 | 丰富视觉效果 |
| 配置系统 | 灵活调整参数 |

**优势**：
- 无需为每张卡牌制作遮罩图
- GPU 加速，性能良好
- 高度可配置
- 支持多种预设

**局限**：
- 需要 GPU 支持（有软件回退）
- 亮度检测可能误识别（可通过调参解决）
